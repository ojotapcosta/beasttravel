<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beast Travel - Match Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        beast: {
                            900: '#111827',
                            800: '#1F2937',
                            700: '#374151',
                            button: '#6366f1'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background: #0f172a;
            font-family: 'Inter', system-ui, sans-serif;
        }

        .glow {
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.15);
        }

        .row-block {
            display: inline-flex;
            gap: 2px;
            padding: 2px 6px;
            background: #1e293b;
            border-radius: 4px;
            margin: 0 3px;
            border: 1px solid #334155;
        }

        .sq {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
        }

        .sq-letter {
            background: #374151;
            color: #9ca3af;
        }

        .sq-icon {
            background: #4f46e5;
            color: #e0e7ff;
            font-size: 10px;
        }

        .match-highlight {
            background: #22c55e20;
            border-color: #22c55e60 !important;
        }

        .no-match {
            opacity: 0.5;
        }
    </style>
</head>

<body class="text-gray-200 min-h-screen">
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="cities.js?v=43"></script>
    <script src="rows.js?v=43"></script>

    <script type="text/babel">
                const { useState, useMemo } =         React;

        // ===== City name variants         database =====
        // For each unmatched city, generate         possible name spellings                   const cityVariants = {
                      // US cities:                y, State (full)
                        "Tampa, Florida":                                       "Tampa, Florida",
                          "Tampa, United States",
            ]                          // Canada cities: City, Prov                 (full)
            "Ye            owk            fe, Northwest Territories": [
                          "Yellowknife, Northwest                 itories",
                "Yello                fe, Canada",
            ],
                        // Other countries: Ci            , C            ntry
            "Georgetown, A                sion Island": [
                             Georgetown, Ascension Island",
                            "Georgetow                aint Helena",
                                     Georgetown, United Kingdom                           ],
                        "Possession I                d, France": [
                            "Possessi                sland, France",
                                    "√éle de la Posses                , France",
                            "Possession Island",
                                    "√éle de la Po                sion",
            ]                          "Iturup, J            an/            ssia": [
                "Iturup, R                a",
                "Iturup, Japa                                "Ituru                land",
                          "It            ofu, Japan",
                            "Etorofu, Japan",
                        ],
                      "            puto, Mozambique": [
                            "Maputo, Mozambique",
                                    "Maputo, Mo                ique",
                          
            "N            ar√©            Portugal": [
                            "Nazar√©, Port                ",
                           Naz            e, Portugal",
                        ],
            "                ns, Queensland, Aus                ia": [
                                      airns, Queensland, Aus                ia",
                               irns, Queensland",
                            "Cairns,                tralia",
            ],
            "Seoul,             uth            orea": [
                "Seoul, So                Korea",
                "Seoul, K                ",
            ],
            "Up                Hutt, New Zealand": [
                                    "Upper Hutt, New                land",
            ]                          "Babylon, Iraq": [                                     "Babylo                raq",
                            "Babil, Iraq            
                      ],
            "                , Maldives": [
                            "Mal√©, Maldives",                             "Male,             ldi            s",
            ],
                        "Qingdao, China": [
                                    "Qingdao, China",
                            "Tsingtao, C                ",
                "Qƒ´ngd                China",
            ],
                                "Salvador, Brazil": [
                            "Salvador, B            zil            
                "Salvador, Bahia",
                "Salvador, Brasil",
                          "S√£o Salvador da Bahia d                dos os Santos",
                        ],
            "Jos√©            e S        an M        art√≠n, Argentina": [
                        "Jos√© de San Mart√≠n, Arge            in a",
                  "Jose de San Martin, Arg en tina",
                 " San Mart√≠n, Argenti            ", 
            ],
              "Derby,  A ustralia": [
                  "Derby, Australia            
                 "Derby , W estern Australia",
              ],
            "Hasik, O            n":  [
                 "Ha sik, Oman",
                  "·∏§ƒÅs ik,  Oman",
            ]                         "Marrakesh , M orocco": [
                  "Marrakesh, M oro cco",
                          "Ma rrakech, Morocc o", 
                "Marr ake ch, Maroc",
                       ],
            "Cochabamba , B olivia": [
                  "Cochabamba, Bolivia",
                       ],
              "Tacurong, Ph ili ppine": [
                           "Tacurong, Phili ppi ne",
                  "Tacurong, Philip pin es",
                          "T acurong, Sultan  Kud arat",
            ],
              "Monkey Bay, Malawi"            [
                 "Monkey  Ba y, Malawi",
              ],
            // Okato              lo cked to row 82 but a lso  excluded ‚Äî if it sh ows  as unmatched, incl ude  it
            "Oka            , N ew Zealand": [
                  "Okato, N ew  Zealand",
                          "≈å kato, New Zeala nd" ,
            ],
        };
 
         // Known sol            ion s (same as app.j sx) 
        const knownSo lut ions = {
            0            'Mo sul, Iraq', 1:  'Ch arlotte, North  Car olina', 2: 'Ambanja, Mad            asc ar', 3: 'Arzamas,  Rus sia',
             4:  'Casper, Wyoming',  6:  'Genoa, Italy', 7:         'Ga        borone, Botswana', 8: 'Nova Russas, Brazil',
            9: 'Kabul, Afghanistan', 12: 'Lower Hutt, New Zealand', 13: 'Natif Waterfalls,         Oman',
            14: 'Baku, Azerbaijan', 17: 'Cairo, Egypt', 18:         'Pune, India', 19: 'Buffalo, N             York',
            20: 'Tierra del Fuego', 21: "Divo, C√¥te d'Ivoire", 22: 'Nome, Alaska             23: 'Tallinn, Estonia',
            24: 'Sura             India', 25: "L'Ascension, Qu√©bec", 26: 'Antalya, Turkey',
            28: 'Hear            Island, Australia', 29: 'Krasnodar, Russia', 30: 'Eyjafjallaj√∂kul             Iceland',
            32: 'Beatty, Nevada        ',         33: 'Lima, Peru', 35: 'Algiers, A            eria',
            38: 'Quito, Ecuador', 39: 'Arles, France', 40: 'Istanbul, Turkey', 41: 'M        ana        us, Brazil',
            42: 'Vi            y, Sweden', 4             'Christchurch, New Zealand', 48: 'Velingrad,                 aria',
            49: 'Casablanca, Morocco', 50:                    to, Mozambique', 51: 'Ankara, Turkey',
                               Castelo Branco, Portugal', 54: 'Marrakesh, Moro                ,
                                55: '        Edm        onton, Alberta', 57: 'Kupang            Indonesia', 58: 'Orlando, Flor                , 59: 'Lahore, Pakistan'                            60: 'Monkey Bay, Malawi', 64: 'Thane                di            ,             : 'Vladivosto        k,         Russia',
            69: 'DeKalb, Illinois', 70: 'Toad             ck, Arkansas',
            72: 'Saint-Pierre', 76: 'ƒåesk√© Budƒõ            vice, Czechia',
            77: 'Yellowknife, Northwest Terri        tor        ies', 78: 'Moscow            Russia',
            79: 'Curic√≥, Chile', 80: 'Copenhagen, Den            rk', 81: 'Okato, New Zealand',
                        : 'Sokod√©, Togo', 84: 'Accra, Ghana', 86: 'Tashkent, Uzbekistan',
            87:            Dimtu, Ethiopia',             : 'Tijuana, Mexico', 89: 'Montreal, Qu                ', 90: 'Wichita, Kansas'
        };

        const ANSWE                    SE = "IN JIMMYS VAULT FIRST PART STICKS ROAMY RESULTS IN BETWEE            STAGE ONE            NSWER PAIRS LAST PAR            HE SHOWED AT START";
        const answe                ters = ANSWER_PHRASE.replace(/ /g, '').split('');                    function norm            izeCity(name) {
            const normalized = name.normalize("NFD"            replace(/[\u0300-\u036f]/g, "").toU                Case();
                           st wordsRaw = normalized.split(/[^A-Z]+/);
                          const wordLetterCounts = wordsRa                    er(w => w.length > 0).map(w => w.lengt                              const lette                     = wordsRaw.filter(w => w.length > 0).                        ;
            return { wordLetterCounts, lettersFull };                         }

        function getRowWordCounts(row) {
            return k                        => b.filter(i => i.typ                        quare' || i.type === 'icon').l                                  }

        function getIconPosition(row) {
            let p                                      for (let b = 0; b < row.blocks.length;                                            for (let c = 0; c < row.blocks[b].length; c++) {
                    if (row.bl                                ype === 'icon') return pos;
                    if (                                ][c].type === '                                    ;
                                                    }                                    eturn -1                                           function                                     w) {
            for (const b of row.block                                           for (const item of b)                                                                 it                        ===                     ) ret                    em.name;
                                                      }
                       eturn null;
        }

        function matchesStructure(            rdCounts, rowWordCounts) {
            if (wordCoun            .length !== rowWordCounts.length) re                 false;
                           urn wordCounts.every((wc, i) => wc ===                    rdCounts[i]);
        }

        function App() {
                          const [selectedVariants                    electedVariants] = useState({}                               const [filter, setFilter] = useState('');

            consC                        useMemo(() => new Set(Object.values(knownSol                            []);

            // Unmatched rows
                              const unmatchedRows = useMemo(() => {
                                           puzzleRows.map((row, index) => ({ row                                                    .filter(({ index }) => !knownSolutions.hasOwnProperty(index));
                                       

            // Unmatched cities
            const                                 ies = useMemo(() =                                          return citi                                     !lockedC                                    
                                           dCities]);

                                         each unmatched row, compute which city va                                    atch
            const rowMat                                mo((                                                         c                    esult                    
                unmatchedRows.                ach(                ow, index }) =>            
                    const rowWC = getRowWordCounts(row);                               const icn                = getIconPosition(row);
                                    t matches = [];

                    unma                    ies.forEach(cityName => {
                        const variants = cityVariants[c                e]                 cityName];
                                              const selectedVariant = selectedVariants[cit                     || cityName;

                                               k ALL variants
                        variants.forEach(variant => {
                                            const { wordL                            s, lettersFull } = normalizeCity(variant);
                            if (matches                        e(wor                        ounts, rowWC)) {
                                const letter = iconPos >= 0 && iconPos < lettersFull.length ? lettersF                    onPos] : '?                                                 const expectedLetter = answ                        s[index] || '?';
                                                                      hes.push({
                                    cityName,
                                                        variant,
                                    lette                                                                           expectedLetter,                                                         isLetterMatch: l                                    ctedLetter,
                                                             dCounts: wordLetterCounts
                                                      });
                                                                            });
                    });

                                          result[index] = matches;
                                                          return result;
            }, [unmatchedRows, unma                                    electedVariants]);

            // For each city, compute whic                                    atch  
                                          cityMatches = useMemo(() => {
                const result = {};
                unmatchedCities.forEach(cityName => {
                                                                ityVariants[cityName] || [cityName];
                                                                    ];

                    variants.forEach(v                                                                  const { wordLetterCounts, lettersFull } = normalizeCity(variant);

                                                        unmatchedRows.fo                                                     => {
                                                          const rowWC = getRowWordCounts(row);
                                                                    hesStructure(wordLe                                                                                                                  const iconPos                                                        
                                const lett                                                            os < lettersFull.length ? lette                                                                                                                     co                                                 answer                                                ';
                                allMat                                                                                                                         ,
                                                                                                                                                                     ,
                                    expect                                                                          isLette                                                    ectedLetter,
                                                                                wordLetterCounts
                                                                                                  }
                        });
                    });
                                                                cityName] = allMatches;
                                                                        turn re                                                        matc                                                    ws, sel                                                                                                edRows =                                                  ? unmatchedRows.fi                                            > {
                    const m                                                index] || [];
                    return matches.some(m => m.isLetterMatch) ||                                                    ludes(filter);
                })
                : unmatchedRows;

                                                                   <div className="max-w-7                                                                           <header className="mb-8 text-c                                                                  <h1 className="text-3xl                                                        -2">üß©                                                                                                         lassNam                                            
                                                      {unmatchedRows.length}                                                 matchedCities.length} unmatched cities
                        </p>
                                                            f="beast-solver.html" className="text-indigo-400 text-sm hover:underline mt-2 inline-block">‚Üê                                                                      </header>

                                                          lassName="grid grid-cols-1 lg:grid-cols-2 gap-8"                                                            {/* LEFT: Unmatched Rows */}
                        <di                                                                                                                    fon                                                -4 flex                                            2">                                                           <span>üìã</sp                                                {unmatchedRows.length})
                            </h2>
                            <div className="space                                                                                         {unma                                    ({                                 ) =>                                                                                           nst rowWC = getRowWordCounts(row                                                                         const iconPos = getIconPosition(row);
                                                        const iconType = getIconType(row);
                                                      cons                             = answerLetters[index] || '                                                            const m                                    tches[index] || [];
                                                                       atches = matches.filter(m => m.isLetterMatch)                                                            const structMatches = matches.filter                                    terMatch);

                                                              rn (
                                                                <div key={index} className={`bg-beast-800 rounded-lg p-4 border ${letterMatches.length > 0 ? 'border-green-500/50' : 'border-gray-700'}`}>
                                                                      <div className="flex items-center justify-between mb                                                                                 <div className="flex items-c                                                                                              <span className="text-xs font-mono bg-gray-700 px-2 py-1 rounded text-gray-300">
                                                                                                                                                          </span>
                                                    <sp                                                s text-y                                            d">
                                                                                                                  "{expected}"
                                                                                </span>
                                                                                {iconType && (
                                                                                      <span className                                                        0">
                                                                                                                                                        Pos}
                                                        </span>
                                                    )}
                                                                                         >
                                                <span className="text-xs text                                                                                                                                                                                   ]
                                                                                                      </span>                                                                                                                                                                                             al */}
                                            <div className="flex f                                                                                                    {row.blocks.map((block, bi)                                                                                                                                            ame="row-block">
                                                                                            lock.map((item, ci) => (
                                                                                            <div                                                    sq $                                                ' ? 'sq                                            r'}                                                                                              {item                                                üöó' : '_'}
                                                            </div                                                                                        ))}
                                                                                       >
                                                ))}
                                                                            </div>

                                                                                  Matching cities */}
                                            {letterMatches                                                                                                                                                                       me="mt-                                            /20                                            rder-green-700/30">
                                                                                <p className="text-xs text-green-400 font-b                                             ma                                                                                                                                                      tterMat                        ((m, i)                                                                                                                  <div key={i} className="text-xs text-gre00"                                                       {m.variant} ‚Üí "{m.letter}" ‚úì
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {structMatches.length > 0 && (
                                                <div className="mt-2 p-2 bg-gray-800/50 rounded border border-gray-700/30">
                                                    <p className="text-xs text-gray-400 font-bold mb-1">üìê Structure matches (wrong letter):</p>
                                                    {structMatches.map((m, i) => (
                                                        <div key={i} className="text-xs text-gray-500">
                                                            {m.variant} ‚Üí "{m.letter}" (needs "{m.expectedLetter}")
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {matches.length === 0 && (
                                                <p className="text-xs text-red-400 mt-1">‚ùå No matching cities found for structure [{rowWC.join(', ')}]</p>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* RIGHT: Unmatched Cities */}
                        <div>
                            <h2 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
                                <span>üèôÔ∏è</span> Unmatched Cities ({unmatchedCities.length})
                            </h2>
                            <div className="space-y-3">
                                {unmatchedCities.map(cityName => {
                                    const variants = cityVariants[cityName] || [cityName];
                                    const matches = cityMatches[cityName] || [];
                                    const letterMatches = matches.filter(m => m.isLetterMatch);
                                    const hasMatch = matches.length > 0;

                                    return (
                                        <div key={cityName} className={`bg-beast-800 rounded-lg p-4 border ${letterMatches.length > 0 ? 'border-green-500/50' : hasMatch ? 'border-yellow-500/30' : 'border-red-500/30'}`}>
                                            <div className="flex items-center justify-between mb-2">
                                                <h3 className="font-bold text-white text-sm">{cityName}</h3>
                                                <span className={`text-xs px-2 py-0.5 rounded ${letterMatches.length > 0 ? 'bg-green-900 text-green-300' : hasMatch ? 'bg-yellow-900 text-yellow-300' : 'bg-red-900 text-red-300'}`}>
                                                    {letterMatches.length > 0 ? `${letterMatches.length} ‚úì` : hasMatch ? `${matches.length} struct` : 'no match'}
                                                </span>
                                            </div>

                                            {/* Name variants */}
                                            <div className="mb-2">
                                                <p className="text-xs text-gray-500 mb-1">Name variants:</p>
                                                <div className="flex flex-wrap gap-1">
                                                    {variants.map((v, i) => {
                                                        const norm = normalizeCity(v);
                                                        return (
                                                            <span key={i} className="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300" title={`[${norm.wordLetterCounts.join(', ')}] = ${norm.lettersFull}`}>
                                                                {v} <span className="text-gray-500">[{norm.wordLetterCounts.join(',')}]</span>
                                                            </span>
                                                        );
                                                    })}
                                                </div>
                                            </div>

                                            {/* Matching rows */}
                                            {letterMatches.length > 0 && (
                                                <div className="p-2 bg-green-900/20 rounded border border-green-700/30">
                                                    <p className="text-xs text-green-400 font-bold mb-1">‚úÖ Perfect matches:</p>
                                                    {letterMatches.map((m, i) => (
                                                        <div key={i} className="text-xs text-green-300">
                                                            Row {m.rowIndex + 1} using "{m.variant}" ‚Üí "{m.letter}" ‚úì
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {matches.filter(m => !m.isLetterMatch).length > 0 && (
                                                <div className="mt-1 p-2 bg-gray-800/50 rounded border border-gray-700/30">
                                                    <p className="text-xs text-gray-400 font-bold mb-1">üìê Structure only:</p>
                                                    {matches.filter(m => !m.isLetterMatch).map((m, i) => (
                                                        <div key={i} className="text-xs text-gray-500">
                                                            Row {m.rowIndex + 1} "{m.variant}" ‚Üí "{m.letter}" (needs "{m.expectedLetter}")
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                            {matches.length === 0 && (
                                                <p className="text-xs text-red-400">‚ùå No rows match any variant</p>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>

</html>